[{"content":"Heap Profile 中 head 各字段的含义 一个标准的 heap profile 头如下所示：\nheapprofile in_use_object: in_use_space [alloc_object: alloc_space] @ stack_trace Heap Profile 中 heap 各字段的含义  HeapSys，从系统申请的用于 Heap 的内存大小 HeapInuse，正在使用的 Heap HeapIdle，没有使用的 Heap HeapSys = HeapInuse + HeapIdle HeapReleased, HeapIdle 中已经归还给 OS 的部分 HeapIdle - HeapReleased，可以归还给 OS 但是还没归还的部分 Sys - HeapReleased，由 Go 持有的内存 HeapAlloc，分配出去的（由用户持有的）Heap，包括 reachable 的和还没被 GC 到的 NextGC，下一次 GC 的阈值，当 HeapAlloc \u0026gt;= NextGC 时就意味着即将 GC 了 LastGC，最近一次 GC 结束的时间戳  ","permalink":"https://simon0-o.github.io/techs/go/golang-profile-heap/","summary":"简单解析下 go 的 heap profile 中各字段的含义。","title":"Golang Heap Profile 解析"},{"content":"区别和联系 我们经常提到线程、线程组、内核进程、用户进程、轻量级进程等词汇，那么他们之间有什么区别和联系呢？\n首先，我们需要明确一点，Linux 下并没有真正意义上的线程，甚至可以说没有进程这个概念，Linux 下只有 task，其对应的数据结构为 task_struct，这里为了方便说明以及按照比较主流的说法，我们将 task 称之为进程。\n对于一个进程来说，它一定是运行在内存的某个连续或不连续的区域。\n用户进程和内核进程 对于 Linux 来说，有两个概念叫做内核空间和用户空间，以 32 位 x86 架构的 Linux 为例，Linux 的虚拟地址空间为 4GB，其中前 1GB 称为内核空间，后 3GB 称为用户空间，进程运行在内核空间时称为内核态，运行在用户空间称之为用户态。对于用户态进程来说，出于程序设计方便和内存安全的角度等原因，为每个用户态进程引入了独立的虚拟地址空间，其被映射到用户空间。\n用户进程，平时运行在用户态，有自己的虚拟地址空间，但是可以通过中断、系统调用等内陷到内核态。 内核进程，没有独立的地址空间，所有内核线程的地址空间都是一样的，没有自己的地址空间，所以它们的 current-\u0026gt;mm 都为空，其运行在内核空间，本身就是内核的一部分或者说是内核的分身。\n线程、轻量级进程、线程组和用户进程 我们开始说到，Linux 下没有真正意义上的线程，那么 Linux 下的线程指的是什么呢？\n我们说过Linux 下只有 task，对应的数据结构为 task_struct，task_strcut 中就包含了 task 所拥有的各种资源，如果一个运行在用户空间的 task 独占 task_struct 的所有资源，我们说它是一个用户进程，当若干个 task 要共享资源时，我们把这些 task 称之为 LWP（轻量级进程）。我们通常说的 Linux 下的线程，指的也就是这些 LWP。\n总结一下，Linux 的线程只是共享了资源的进程，也就是 LWP，而那些共享了资源的 task 组合在一起，我们称之为线程组。\n即对于普通的用户进程，我们可以认为是只有一个 LWP 的线程组，但对于一个有着多线程的进程（线程组），其中的每一个线程都是 LWP，组内共享资源。在一个普通进程内创建线程时，就是在线程组内增加 LWP。\n进程的创建 在 Linux 下，有着这几个创建进程（task）的函数： fork vfork clone pthread_create kernel_thread 所有的这些函数，最终都是在调用do_fork()，只是传入的参数不同\n fork（sys_fork）在调用 do_fork() 时，clone_flags 没有置位任何 clone 标志位，即创建的进程不共享任何数据。 vfork（sys_vfork）在调用 do_fork() 时，置为了 CLONE_VFORK CLONE_VM，即共享 VM，以及当 mm_release 时子进程唤醒父进程 clone（sys_clone）本身只进行 clone_flags 的传递 pthread_create 则将 CLONE_VM CLONE_FS CLONE_FILES CLONE_SIGHAND 等标志位置位，即共享 VM，共享 fs info，共享打开的文件，共享信号句柄和阻塞的信号？ 即除了栈是独立的，其他都是共享的，所以在 Linux 中，线程仅仅是一个使用共享资源的轻量级进程 kernel_thread 在传递的参数基础上增加了 CLONE_VM 和 CLONE_UNTRACED。   kernel_thread 只能由内核进程调用，创建的进程没有独立虚拟地址空间，只能运行在内核空间，为内核进程。 fork，创建的进程与父进程不共享资源，而是写时复制，故而创建的是用户进程 vfork，带有 CLONE_VM 标志位，故而创建的是 LWP pthread_create，共享各类资源，创建的也是 LWP  关于fork vfork clone pthread_create kernel_thread 以及 do_fork更进一步的细节，先挖个坑，以后再填\n 搬运后记：并没有填\n ","permalink":"https://simon0-o.github.io/techs/linux/process-lwp/","summary":"解析下 Linux 中内核进程、用户进程和轻量级进程（LWP）的区别和联系","title":"Linux 下内核进程、用户进程和轻量级进程（LWP）的理解"},{"content":"环境搭建的问题总结 前言：除非特殊需要，或者系统不支持，否则尽量避免使用源码安装，不然可能会在环境搭建这一步浪费大量时间。即使能正常使用了，也可能在后续的使用中因为各种各样的问题来重走这一过程，为避免这一情况的发生，即使 Tesseract 能正常使用了，也请通过 tesseract -v 来确认自己需要的库都已经成功被 Tesseract 找到。\n一、configure 提示 leptonica library missing configure 输出（最后几行）：\nchecking for leptonica... yes checking for pixCreate in -llept... no configure: error: leptonica library missing 我们看到checking for leptonica... yes，那么 leptonica 是安装成功的，但是却没有找到 lib，那么我们通过环境变量和 configure 参数让它找到 export LIBLEPT_HEADERSDIR=/usr/local/include ./configure --enable-shared --with-extra-libraries=/usr/local/lib （使用\u0026ndash;enable-shard 原因见下）\n二、make 时提示各类 undefined symbol 情况有两种\n（1）各类依赖安装不完全 If they are not already installed, you need the following libraries (Ubuntu 16.04/14.04):\nsudo apt-get install g++ # or clang++ (presumably) sudo apt-get install autoconf automake libtool sudo apt-get install autoconf-archive sudo apt-get install pkg-config sudo apt-get install libpng-dev sudo apt-get install libjpeg8-dev sudo apt-get install libtiff5-dev sudo apt-get install zlib1g-dev if you plan to install the training tools, you also need the following libraries:\nsudo apt-get install libicu-dev sudo apt-get install libpango1.0-dev sudo apt-get install libcairo2-dev 如果提示 undefined reference to TIFFXXX@LIBTIFF_4.0' ，可能是因为 libtiff4 和 libtiff5 冲突所致，请将所有的 libtiff 的库文件删除干净后，重新安装 libtiff4-dev 后再次安装\n（2）tesseract 和 leptonica 版本不一致    Tesseract Leptonica Ubuntu     4.00 1.74.2 Must build from source   3.05 1.74.0 Must build from source   3.04 1.71 Ubuntu 16.04   3.03 1.70 Ubuntu 14.04   3.02 1.69 Ubuntu 12.04   3.01 1.67     三、tesseract 运行提示 cannot open shared object file 提示信息：tesseract: error while loading shared libraries: libtesseract.so.3: cannot open shared object file: No such file or directory\n采用 Linux 下的开发经验总结 中的通用方法即可解决\n训练过程的经验总结 一、使用 jTessboxeditor 生成 tif 和 box 文件的技巧 情况分析： 网上的许多教程都是通过这样一个方式得到 tif 文件和 box 文件：\n 准备文字数据 利用 jTessboxeditor（或其他工具）将文字数据生成为 tif 文件 用 tesseract 对 tif 文件作识别和标记（姑且这么称呼这个过程）得到 box 文件 利用 jTessboxeditor 调整 box 文件，之后就可以用 tesseract 生成训练文件了。  但是一旦实际操作起来，尤其是文字数据量较大时，就会发现这个过程十分低效。 在使用 jTessboxeditor 生产 tif 文件的时候，我们会发现也帮我们生成了一个 box 文件，那么这个 box 文件得到的过程和利用 tesseract 生成 box 文件有何不同呢？\n我作出如下分析：\n 我们不难想象，jTessbxeditor 为了生产 tif 文件，一定是有每个字符的位置信息的，那么 jTessboxeditor 其实既含有一个 blob 的位置信息，又有其对应的真实的字符（根据文字数据），那么理所应当应该生成出一个具有准确信息的 box 文件 那么 tesseract 又是如何生成 box 文件的呢，其实我们可以简单的理解为 tesseract 其实就是在识别一副再普通不过的图片，只不过她不仅输出了识别到的字符，还把对应的像素区域框定了出来，也就是 box 文件（box 文件本质上，每一行的内容就是一个字符加一个对应页上的矩形区域），也就是说 tesseract 生成的 box 文件是识别出来的，那自然避免不了一个问题，误识别  所以，这里给出高效的生成 tif 和 box 文件的顺序： 1.准备文字数据 2.利用 jTessboxeditor 将文字数据生成为 tif 文件和 box 文件，tesseract 直接用步骤 2 的 tif 和 box 文件生成训练文件\nTips:\n 如果你发现 jTessboxeditor 生成的 box 文件中存在大量的 blob 错位的情况，请将文本数据分成多份，以生成多个文件（目前测试中，在 tif 文件只有 1 页的情况下 box 没发现过错位的情况） 多个 tif 文件和 box 文件可以在后面生产字典的时候得到合并，请注意命名的统一（如 AAA.BBB.exp0 AAA.BBB.exp1 \u0026hellip;）  二、FAILURE! Couldn\u0026rsquo;t find a matching blob FAIL 错误提示APPLY_BOXES: boxfile line XXX/X ((XXXX,XXXX),(XXXX,XXXX)): FAILURE! Couldn't find a matching blob FAIL!\n情况分析：jTessboxeditor 中每个方框和字符对应都很正确，tesseract 生成训练文件时却提示找不到匹配的 blob（虽然我认为方框和实际文字有没有对齐以及是否和字符匹配都和这个错误没什么关系）\n经借鉴一些前人的解决经验，初步认为是 tesseract 对 box 文件和 tif 文件中的 blob 和 page 的位置界定有问题\n解决步骤： 消除了生成 tif 文件的文字之间的所有空格，然后生成 tif 文件和 box 文件，再次生成训练文件，无错误产生。如果还有错误，可尝试调整出错的字符到其他位置（如与旁边的字符交换位置等）。\n三、多种字体的训练 情况分析：我之前训练了一种名为 myChi 的语言（couriernewb 字体）的数据，现在我想增加一种字体\n解决步骤：直接用 jTessboxeditor 生成新的字体的 tif 和 box 文件，步骤同上，注意文件名的语言名字要同为 myChi。此时 jTessboxeditor 会自动在已有的 myChi.font_properties 文件中再增加一行，增加的一行为新增的字体的数据。后续步骤同上。\n四、误识别的纠正 情况分析：训练过程中遇到误识别是非常正常的事情，这里提供一些解决技巧\n解决步骤：\n 考虑是否是由于字体的原因造成误识别，如字体类型，大小，是否加粗等，然后根据情况增加所需的 tif 和 box 文件 考虑是否是因为训练的文本中相似字符过多，或者不同类型的字符过于混杂等（比如数字和汉字之间的误识别），根据情况可用 opencv 等对图片进行一定分割，比如某些区域只含有数字，可把该区域单独分割出来，用只含有数字的语言进行识别 对于不好判断的情况，可用上述的一里面提到的思想，把有误识别的图片生成 box 文件，用 jTessboxeditor 进一步确定是哪些部分造成的误识别，再思考可能的解决办法 tesseract XXX.jpg XXX -l language makebox 一些情况可通过增加文字内容的方式解决误识别，比如图片中含有 2016 的字样，但是识别出来为 2015 等，可考虑在文字数据部分加入 2016，来增加对该字样的识别率。（不确定是否真的有效，但测试下来确实有几次是有效的）  ","permalink":"https://simon0-o.github.io/techs/other/tesseract-ocr/","summary":"Tesseract Ocr 使用记录","title":"Tesseract Ocr"}]